<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Void Runner</title> <!-- MODIFIED: New Name -->
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Orbitron font -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <!-- MODIFIED: Removed Tone.js from here -->
    <style>
        body {
            font-family: 'Orbitron', sans-serif;
            overflow: hidden; /* Prevent scrolling on mobile */
            touch-action: none; /* Disable panning and zooming */
            
            /* Full-page space background */
            background-color: #1A0A2A; /* Dark Purple */
            background-image: 
                radial-gradient(circle at 20% 30%, rgba(200, 150, 255, 0.2), transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(180, 100, 220, 0.15), transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(220, 180, 255, 0.05), transparent 20%);
            background-size: 100% 100%;
        }
        canvas {
            background-color: transparent; /* Canvas is transparent, body has bg */
            touch-action: none; 
        }
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
            backdrop-filter: blur(5px);
        }
        /* MODIFIED: Make modal wider for leaderboard */
        #gameModal {
            width: 90%;
            max-width: 600px; /* Wider modal */
            max-height: 90vh;
            overflow-y: auto;
        }
        /* MODIFIED: Toned down the glow for readability */
        .text-glow-cyan {
            color: #e0faff;
            text-shadow: 0 0 1px #0ff, 0 0 3px #0ff, 0 0 8px #0ff; /* Reduced blur */
        }
        .text-glow-yellow {
            color: #fffde0;
            text-shadow: 0 0 2px #ff0, 0 0 6px #ff0, 0 0 12px #ff0;
        }
        /* NEW: Clean subtitle font */
        .text-subtitle {
            font-family: Arial, sans-serif; /* Use a clean font */
            color: #cbd5e1; /* slate-300 */
        }

        /* Leaderboard Styles (REMOVED - Not in use) */
        .leaderboard-container { display: none; }
        .leaderboard-list { display: none; }
    </style>
</head>
<!-- MODIFIED: h-screen to fill viewport -->
<body class="text-white flex flex-col items-center h-screen pt-4 pb-12"> <!-- MODIFIED: Increased pb-8 to pb-12 -->

    <!-- Game Title -->
    <h1 class="text-3xl md:text-4xl font-bold mb-2 text-glow-cyan">Void Runner</h1> <!-- MODIFIED: New Name -->

    <!-- Score Display -->
    <div class="mb-2 text-lg md:text-2xl">
        Score: <span id="score" class="font-bold text-glow-yellow">0</span>
    </div>

    <!-- NEW: Hidden <video> for Cat Memes -->
    <video id="catMemePlayer"
        class="hidden z-[100] absolute top-4 left-4 rounded-lg shadow-2xl border-2 border-cyan-300 w-32 h-auto" <!-- MODIFIED: w-48 to w-32 -->
        src=""
        controls 
        preload="none"
        playsinline <!-- NEW: Prevents fullscreen on mobile -->
    ></video>

    <!-- NEW: Hidden <video> for Shield Power-up -->
    <video id="shieldVideoPlayer"
        class="hidden z-[100] absolute top-4 right-4 rounded-lg shadow-2xl border-2 border-green-400 w-32 h-auto" <!-- MODIFIED: w-48 to w-32 -->
        src=""
        controls 
        preload="none"
        playsinline <!-- NEW: Prevents fullscreen on mobile -->
    ></video>

    <!-- Game Canvas Container -->
    <!-- MODIFIED: This container will define the game size -->
    <div id="game-container" class="w-full flex-1 rounded-lg shadow-2xl overflow-hidden border-2 border-purple-400">
        <canvas id="gameCanvas" class="w-full h-full"></canvas>
    </div>

    <!-- Mobile Touch Controls -->
    <!-- MODIFIED: Removed max-w-lg, added padding -->
    <div class="md:hidden w-full mt-2 grid grid-cols-2 gap-4 px-4 pb-4"> <!-- MODIFIED: Increased pb-2 to pb-4 -->
        <button id="moveLeftBtn" class="bg-gradient-to-b from-purple-600 to-purple-800 border-2 border-cyan-300 text-white font-bold py-4 rounded-lg shadow-lg active:scale-95 transition-transform duration-200 shadow-purple-500/50 active:shadow-none">
            &larr; Left
        </button>
        <button id="moveRightBtn" class="bg-gradient-to-b from-purple-600 to-purple-800 border-2 border-cyan-300 text-white font-bold py-4 rounded-lg shadow-lg active:scale-95 transition-transform duration-200 shadow-purple-500/50 active:shadow-none">
            Right &rarr;
        </button>
    </div>

    <!-- Game Over / Start Modal -->
    <div id="modalBackdrop" class="modal-backdrop hidden">
        <div id="gameModal" class="bg-gradient-to-b from-gray-800 to-gray-900 p-8 rounded-lg shadow-2xl shadow-cyan-500/50 text-center border-2 border-cyan-300">
            <!-- MODIFIED: Replaced octopus img with a video player for the end screen -->
            <video id="endScreenVideo" src="" class="w-full max-w-sm mx-auto mb-4 rounded-lg hidden" controls preload="none" playsinline></video> <!-- NEW: Added playsinline -->
            <h2 id="modalTitle" class="text-3xl font-bold mb-4 text-glow-cyan">Game Over!</h2>
            <!-- MODIFIED: Removed glow from subtitle -->
            <p id="modalScore" class="text-xl mb-6 text-subtitle">Your Score: 0</p>
            
            <!-- Submit Score Form (REMOVED) -->
            <div id="submitScoreForm" class="hidden"></div>

            <!-- "Play Again" / "Start Game" Button -->
            <button id="restartButton" class="bg-yellow-500 text-gray-900 font-bold py-3 px-8 rounded-lg text-xl transform transition-all duration-300 hover:scale-105 shadow-lg shadow-yellow-500/50 hover:shadow-yellow-300/50">
                Play Again
            </button>

            <!-- Leaderboard Section (REMOVED) -->
            <div id="leaderboard-modal-container" class="hidden"></div>

        </div>
    </div>

    <!-- MODIFIED: Moved Tone.js script here, to the end of the body -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <script type="module">
        // --- Firebase SDK Imports (REMOVED) ---

        // --- Declare variables, assign them after DOM loads ---
        let canvas, ctx;
        let scoreEl, modalBackdrop, modalTitle, modalScore, restartButton, endScreenVideo; // MODIFIED
        let moveLeftBtn, moveRightBtn, gameContainer;
        let catMemePlayer; // MODIFIED
        let shieldVideoPlayer; // NEW: For cat5.mp4
 

        // --- Game State Variables ---
        let player, obstacles = [], score = 0, lives = 3;
        let gameSpeed = 1.0, isGameOver = false, animationFrameId;
        let obstacleSpawnTimer = 0, obstacleSpawnInterval = 100;
        let shieldTimer = 0;
        const SHIELD_DURATION = 300; // 5 seconds
        let moveLeft = false, moveRight = false;
        let catMemeTimeout; // MODIFIED: Renamed from catVideoTimeout
        let endScreenVideoTimeout; // NEW: Timer for end screen video
        let shieldVideoTimeout; // NEW: Timer for shield video
 
        // --- NEW: Add your Cat Meme filenames here! ---
        // 1. Upload your .mp4 files to GitHub
        // 2. Add the exact filenames to this list
        const catMemeFiles = [
            "cat1.mp4", // Example 1
            "cat2.mp4", // Example 2
            // "my-funny-cat.mp4"
        ];
        
        // --- AAA Feature Variables ---
        let particles = [];
        let stars = [];

        // --- Image Assets ---
        let playerImage = new Image(), playerImageLoaded = false;
        const playerImageFilename = 'spaceship.png';
        let logoImage = new Image(), logoImageLoaded = false;
        const logoImageFilename = 'logo.png';
        let meteorImage = new Image(), meteorImageLoaded = false;
        const meteorImageFilename = 'meteor.png';
        // let octopusImage = new Image(), octopusImageLoaded = false; // REMOVED

        // --- Firebase Variables (REMOVED) ---

        // --- Hybrid Sound System ---
        let sounds = {
            music: new Audio('music.mp3'), // Your music file
            shield: null, 
            hit: null,    
            gameover: null,
            fanfare: null // NEW: Fun sound for game over
        };
        sounds.music.loop = true;
        sounds.music.volume = 0.05; // 5% volume
        let soundInitialized = false;

        // --- Initialize Tone.js sounds ---
        function initSounds() {
            if (typeof Tone === 'undefined') {
                console.warn("Tone.js not loaded. Sound effects will be silent.");
                return;
            }
            sounds.shield = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.2 } }).toDestination();
            sounds.shield.volume.value = 0;
            sounds.hit = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.01, decay: 0.15, sustain: 0, release: 0.1 } }).toDestination();
            sounds.hit.volume.value = -10;
            sounds.gameover = new Tone.MonoSynth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.5 } }).toDestination();
            sounds.gameover.volume.value = -5;
            
            // NEW: Fanfare sound
            sounds.fanfare = new Tone.PolySynth(Tone.Synth, {
                envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 }
            }).toDestination();
            sounds.fanfare.volume.value = -5;
            
            console.log("Sound effects initialized");
            soundInitialized = true;
        }

        // --- playSound function ---
        function playSound(sound) {
            if (!soundInitialized && sound !== 'music') return;
            if (sound === 'music') {
                sounds.music.currentTime = 0;
                sounds.music.play().catch(e => console.warn("Music play failed:", e.message));
            } 
            else if (sound === 'shield' && sounds.shield) sounds.shield.triggerAttackRelease("C5", "8n");
            else if (sound === 'hit' && sounds.hit) sounds.hit.triggerAttackRelease("16n");
            else if (sound === 'gameover' && sounds.gameover) sounds.gameover.triggerAttackRelease("C3", "2n");
            // NEW: Play fanfare
            else if (sound === 'fanfare' && sounds.fanfare) {
                const now = Tone.now();
                sounds.fanfare.triggerAttackRelease("C4", "8n", now);
                sounds.fanfare.triggerAttackRelease("E4", "8n", now + 0.1);
                sounds.fanfare.triggerAttackRelease("G4", "8n", now + 0.2);
                sounds.fanfare.triggerAttackRelease("C5", "4n", now + 0.3);
            }
        }
        
        // --- Firebase Initialization (REMOVED) ---
        
        // --- NEW: Function to play a random cat meme ---
        function playRandomCatMeme() {
            try {
                if (catMemeFiles.length === 0) return; // Don't do anything if no files are listed

                // Clear any previous meme timeout
                if (catMemeTimeout) clearTimeout(catMemeTimeout);

                const randomFile = catMemeFiles[Math.floor(Math.random() * catMemeFiles.length)];
                
                // Set the video source
                catMemePlayer.src = randomFile;
                
                // Show the player
                catMemePlayer.classList.remove('hidden');

                // Try to play it (will be silent if autoplay is blocked)
                catMemePlayer.play().catch(e => {
                    console.warn("Video autoplay blocked. User must click play.", e.message);
                });

                // Set a timer to hide the player after 10 seconds
                catMemeTimeout = setTimeout(() => {
                    catMemePlayer.classList.add('hidden');
                    catMemePlayer.src = ''; // Clear src
                }, 10000); // 10 seconds

            } catch(e) {
                console.error("Could not play cat meme:", e);
            }
        }

        // --- NEW: Function to play cat5.mp4 on shield pickup ---
        function playShieldVideo() {
            try {
                // Clear any previous timeout
                if (shieldVideoTimeout) clearTimeout(shieldVideoTimeout);

                // Set the video source
                shieldVideoPlayer.src = 'cat5.mp4';
                
                // Show the player (on the right side)
                shieldVideoPlayer.classList.remove('hidden');

                // Try to play it
                shieldVideoPlayer.play().catch(e => {
                    console.warn("Shield video autoplay blocked. User must click play.", e.message);
                });

                // Set a timer to hide the player after 5 seconds
                shieldVideoTimeout = setTimeout(() => {
                    shieldVideoPlayer.classList.add('hidden');
                    shieldVideoPlayer.src = ''; // Clear src
                }, 5000); // 5 seconds

            } catch(e) {
                console.error("Could not play cat5.mp4:", e);
            }
        }

        // --- Load Leaderboard Data (REMOVED) ---
        // --- Display Leaderboard (REMOVED) ---
        // --- Submit Score (REMOVED) ---

        // --- Load Images ---
        function loadAllImages() {
            playerImage.src = playerImageFilename;
            playerImage.onload = () => playerImageLoaded = true;
            playerImage.onerror = () => console.error("Error loading player image");
            logoImage.src = logoImageFilename;
            logoImage.onload = () => logoImageLoaded = true;
            logoImage.onerror = () => console.error("Error loading logo image");
            meteorImage.src = meteorImageFilename;
            meteorImage.onload = () => meteorImageLoaded = true;
            meteorImage.onerror = () => console.error("Error loading meteor image");
            // octopusImage.src = octopusImageFilename; // REMOVED
        }


        // --- Game Functions ---

        // MODIFIED: Resize canvas to non-square
        function resizeCanvas() {
            const container = gameContainer;
            const dpr = window.devicePixelRatio || 1;
            
            // Get CSS size
            const cssWidth = container.clientWidth;
            const cssHeight = container.clientHeight;

            // Set internal resolution
            canvas.width = cssWidth * dpr;
            canvas.height = cssHeight * dpr;

            // Set display size (redundant, but good practice)
            canvas.style.width = cssWidth + 'px';
            canvas.style.height = cssHeight + 'px';
            
            ctx.scale(dpr, dpr);
            
            // Recalculate player size/position
            if (player) {
                // MODIFIED: Use gameContainer dimensions
                const oldHeight = player.height / 0.1; // old height was 10% of canvas height
                const oldXRatio = player.x / (oldHeight * (cssWidth / cssHeight)); // approx old width
                
                // New size based on new *height*
                player.width = cssHeight * 0.1; // Player size is 10% of height
                player.height = player.width;
                player.speed = cssWidth * 0.008; // Speed based on width
                
                // Reposition
                player.x = (player.x / (gameContainer.clientWidth || 1)) * cssWidth;
                player.y = cssHeight - player.height - 10; // 10px from bottom
            }
            
            initStars(cssWidth, cssHeight);

            if (!isGameOver) {
                ctx.clearRect(0, 0, cssWidth, cssHeight);
                if(player) drawPlayer();
                updateAndDrawObstacles();
            }
        }

        // MODIFIED: Create player for non-square
        function createPlayer() {
            // MODIFIED: Use gameContainer
            const cssWidth = gameContainer.clientWidth;
            const cssHeight = gameContainer.clientHeight;
            const playerSize = cssHeight * 0.1; // 10% of height
            return {
                x: cssWidth / 2 - playerSize / 2,
                y: cssHeight - playerSize - 10, // 10px from bottom
                width: playerSize,
                height: playerSize,
                speed: cssWidth * 0.008,
                isShielded: false,
                invincibilityTimer: 0
            };
        }

        // Draw player (unchanged)
        function drawPlayer() {
            if (player.isShielded) {
                ctx.save();
                const centerX = player.x + player.width / 2;
                const centerY = player.y + player.height / 2;
                const radius = player.width * 0.7;
                const pulse = Math.abs(Math.sin(Date.now() * 0.01));
                ctx.fillStyle = `rgba(238, 130, 238, ${0.2 + pulse * 0.2})`;
                ctx.strokeStyle = `rgba(255, 0, 255, ${0.6 + pulse * 0.3})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }
            if (player.invincibilityTimer > 0 && Math.floor(player.invincibilityTimer / 10) % 2 === 0) {
                // Skip drawing to flicker
            } else {
                if (playerImageLoaded) {
                    ctx.drawImage(playerImage, player.x, player.y, player.width, player.height);
                } else {
                    ctx.fillStyle = '#4A90E2';
                    ctx.shadowColor = '#81D4FA';
                    ctx.shadowBlur = 15;
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                    ctx.shadowBlur = 0;
                }
            }
        }

        // MODIFIED: Draw UI for non-square
        function drawUI() {
            // MODIFIED: Use gameContainer
            const cssHeight = gameContainer.clientHeight;
            const lifeSize = cssHeight * 0.05; // 5% of height
            const padding = cssHeight * 0.02;
            ctx.save();
            if (playerImageLoaded) {
                ctx.globalAlpha = 0.8;
                for (let i = 0; i < lives; i++) {
                    ctx.drawImage(playerImage, padding + i * (lifeSize + padding / 2), cssHeight - lifeSize - padding, lifeSize, lifeSize);
                }
                ctx.globalAlpha = 1.0;
            } else {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
                for (let i = 0; i < lives; i++) {
                    ctx.fillRect(padding + i * (lifeSize + padding / 2), cssHeight - lifeSize - padding, lifeSize, lifeSize);
                }
            }
            ctx.restore();
        }

        // MODIFIED: Update player for non-square
        function updatePlayer() {
            if (moveLeft) player.x -= player.speed;
            if (moveRight) player.x += player.speed;
            if(moveLeft || moveRight) emitThrusterParticles();

            // MODIFIED: Use gameContainer
            const cssWidth = gameContainer.clientWidth;
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > cssWidth) player.x = cssWidth - player.width;
        }

        // MODIFIED: Create falling object for non-square
        function createFallingObject() {
            // MODIFIED: Use gameContainer
            const cssWidth = gameContainer.clientWidth;
            const cssHeight = gameContainer.clientHeight;
            const objectSize = Math.random() * (cssWidth * 0.05) + (cssWidth * 0.02); // Based on width
            let objectType = 'meteor', baseSpeed = gameSpeed;
            const rand = Math.random();
            if (rand < 0.05 && score > 200) {
                objectType = 'booster';
                baseSpeed = gameSpeed * 1.2;
            } else if (rand < 0.10 && score > 100) {
                objectType = 'bomb';
                baseSpeed = gameSpeed * 1.1;
            }
            
            // --- BUG FIX: Ensure speed is always positive ---
            const calculatedSpeed = (Math.random() * 2 + baseSpeed);
            
            obstacles.push({
                x: Math.random() * (cssWidth - objectSize), y: -objectSize,
                width: objectSize, height: objectSize,
                speed: Math.max(1.0, calculatedSpeed), // Failsafe, speed must be at least 1.0
                type: objectType
            });
        }

        // Draw bomb (unchanged)
        function drawBomb(x, y, radius) {
            ctx.save();
            const centerX = x + radius, centerY = y + radius;
            ctx.beginPath(); ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = '#222'; ctx.shadowColor = '#000'; ctx.shadowBlur = 10; ctx.fill();
            ctx.beginPath(); ctx.arc(centerX, centerY - radius * 0.8, radius * 0.2, 0, 2 * Math.PI);
            ctx.fillStyle = '#999'; ctx.fill();
            ctx.beginPath(); ctx.moveTo(centerX, centerY - radius * 0.9);
            ctx.lineTo(centerX + radius * 0.1, centerY - radius * 1.2);
            ctx.strokeStyle = '#555'; ctx.lineWidth = 3; ctx.stroke();
            ctx.beginPath(); ctx.arc(centerX + radius * 0.1, centerY - radius * 1.2, radius * 0.15, 0, 2 * Math.PI);
            ctx.fillStyle = 'yellow'; ctx.shadowColor = 'orange'; ctx.shadowBlur = 15; ctx.fill();
            ctx.restore();
        }

        // Draw booster (unchanged)
        function drawBooster(x, y, radius) {
            ctx.save();
            const centerX = x + radius, centerY = y + radius;
            ctx.beginPath(); ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            const gradient = ctx.createRadialGradient(centerX, centerY, radius * 0.2, centerX, centerY, radius);
            gradient.addColorStop(0, 'rgba(200, 255, 200, 1)');
            gradient.addColorStop(0.5, 'rgba(0, 255, 0, 0.8)');
            gradient.addColorStop(1, 'rgba(0, 150, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.shadowColor = '#00FF00'; ctx.shadowBlur = 20; ctx.fill();
            ctx.restore();
        }

        // MODIFIED: Update/draw obstacles for non-square
        function updateAndDrawObstacles() {
            // MODIFIED: Use gameContainer
            const cssHeight = gameContainer.clientHeight;
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i];
                obs.y += obs.speed;
                if (obs.type === 'meteor') {
                    if (meteorImageLoaded) ctx.drawImage(meteorImage, obs.x, obs.y, obs.width, obs.height);
                    else { ctx.fillStyle = '#8B4513'; ctx.fillRect(obs.x, obs.y, obs.width, obs.height); }
                } else if (obs.type === 'bomb') drawBomb(obs.x, obs.y, obs.width / 2);
                else if (obs.type === 'booster') drawBooster(obs.x, obs.y, obs.width / 2);

                if (obs.y > cssHeight) {
                    obstacles.splice(i, 1);
                    score += 10;
                    scoreEl.textContent = score;
                    // This logic is replaced in gameLoop, but harmless
                    // if (score >= 500 && score % 100 === 0) gameSpeed += 0.2; 
                }
            }
        }

        // Check collisions (unchanged)
        function checkCollisions() {
            if (player.invincibilityTimer > 0) return;
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i];
                const padding = player.width * 0.15;
                if (player.x < obs.x + obs.width - padding && player.x + player.width > obs.x + padding &&
                    player.y < obs.y + obs.height - padding && player.y + player.height > obs.y + padding) {
                    if (obs.type === 'booster') {
                        player.isShielded = true;
                        shieldTimer = SHIELD_DURATION;
                        obstacles.splice(i, 1);
                        playSound('shield');
                        emitParticles(player.x + player.width / 2, player.y + player.height / 2, 20, '#00FF00');
                        playShieldVideo(); // --- NEW: Play cat5.mp4 ---
                    } else if (obs.type === 'meteor' || obs.type === 'bomb') {
                        if (player.isShielded) {
                            obstacles.splice(i, 1);
                            playSound('hit');
                            emitParticles(obs.x + obs.width / 2, obs.y + obs.height / 2, 30, '#FF00FF');
                        } else {
                            lives--;
                            playSound(obs.type === 'bomb' ? 'gameover' : 'hit');
                            emitParticles(player.x + player.width / 2, player.y + player.height / 2, 40, '#FF4500');
                            obstacles.splice(i, 1);
                            if (lives <= 0) {
                                gameOver();
                                break;
                            } else {
                                player.invincibilityTimer = 240;
                                playRandomCatMeme(); // --- MODIFIED: Play meme ---
                            }
                        }
                    }
                }
            }
        }

        // MODIFIED: Game over (to show leaderboard & confetti)
        function gameOver() {
            isGameOver = true;
            cancelAnimationFrame(animationFrameId);
            
            // NEW: Hide cat video on Game Over
            catMemePlayer.classList.add('hidden'); // MODIFIED
            catMemePlayer.src = ''; // MODIFIED
            if (catMemeTimeout) clearTimeout(catMemeTimeout); // MODIFIED
            
            // NEW: Hide shield video on Game Over
            shieldVideoPlayer.classList.add('hidden');
            shieldVideoPlayer.src = '';
            if (shieldVideoTimeout) clearTimeout(shieldVideoTimeout);
            
            // NEW: Play fanfare and stop music
            playSound('fanfare'); 
            sounds.music.pause();
            
            // NEW: Emit confetti
            // MODIFIED: Use gameContainer
            emitConfetti(gameContainer.clientWidth, gameContainer.clientHeight);
            
            modalTitle.textContent = 'Game Over!';
            modalScore.innerHTML = `Your Score: <span class="font-bold text-glow-yellow">${score}</span>`;
            
            // MODIFIED: Show cat4.mp4 video
            try {
                if (endScreenVideoTimeout) clearTimeout(endScreenVideoTimeout); // Clear previous
                endScreenVideo.src = 'cat4.mp4';
                endScreenVideo.classList.remove('hidden');
                endScreenVideo.play().catch(e => {
                    console.warn("End screen video autoplay blocked. User must click play.", e.message);
                });
                
                // --- NEW: Hide video after 5 seconds ---
                endScreenVideoTimeout = setTimeout(() => {
                    endScreenVideo.classList.add('hidden');
                    endScreenVideo.src = '';
                }, 5000); // 5 seconds
                // --- END NEW ---

            } catch (e) {
                console.error("Could not load cat4.mp4", e);
            }
            
            // MODIFIED: Removed code that showed the submit form and leaderboard
            restartButton.classList.remove('hidden');
            restartButton.textContent = 'Play Again';
            modalBackdrop.classList.remove('hidden');
        }

        // MODIFIED: Start/restart game
        function initGame() {
            // --- NEW: Failsafe check for container size ---
            resizeCanvas(); // Try to resize
            const cssWidth = gameContainer.clientWidth;
            const cssHeight = gameContainer.clientHeight;

            if (cssWidth === 0 || cssHeight === 0) {
                console.error(`Game container size is ${cssWidth}x${cssHeight}. Retrying in 50ms...`);
                setTimeout(initGame, 50); // Try again shortly
                return; // Stop execution
            }
            // --- END NEW ---

            // If we get here, cssWidth and cssHeight are valid
            console.log(`Game container size is ${cssWidth}x${cssHeight}. Starting game.`);

            initStars(cssWidth, cssHeight);
            player = createPlayer();
            obstacles = [];
            particles = []; // Clear confetti
            score = 0;
            lives = 3;
            gameSpeed = 1.0;
            isGameOver = false;
            obstacleSpawnTimer = 0;
            obstacleSpawnInterval = 80; // MODIFIED: Start with a faster spawn rate (was 100)
            shieldTimer = 0;
            scoreEl.textContent = '0';
            modalBackdrop.classList.add('hidden');
            
            // MODIFIED: Hide end screen video
            endScreenVideo.classList.add('hidden');
            endScreenVideo.src = ''; // Stop it from playing
            if (endScreenVideoTimeout) clearTimeout(endScreenVideoTimeout); // Clear timer
        
            // MODIFIED: Hide cat video on Restart
            catMemePlayer.classList.add('hidden'); // MODIFIED
            catMemePlayer.src = ''; // MODIFIED
            if (catMemeTimeout) clearTimeout(catMemeTimeout); // MODIFIED

            // NEW: Hide shield video on Restart
            shieldVideoPlayer.classList.add('hidden');
            shieldVideoPlayer.src = '';
            if (shieldVideoTimeout) clearTimeout(shieldVideoTimeout);
            
            playSound('music');
            gameLoop();
        }
        
        // --- Particle Functions (unchanged) ---
        function emitParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4,
                    size: Math.random() * 3 + 1, color: color,
                    life: Math.random() * 60 + 30
                });
            }
        }
        function emitThrusterParticles() {
            if (!player) return;
            for (let i = 0; i < 2; i++) {
                particles.push({
                    x: player.x + player.width / 2 + (Math.random() - 0.5) * (player.width * 0.5),
                    y: player.y + player.height,
                    vx: (Math.random() - 0.5) * 0.5, vy: Math.random() * 2 + 1.5,
                    size: Math.random() * 2 + 1, color: '#FF4500',
                    life: Math.random() * 30 + 20
                });
            }
        }

        // --- NEW: Confetti Particle Emitter ---
        function emitConfetti(width, height) {
            const confettiColors = ['#f94144', '#f3722c', '#f8961e', '#f9c74f', '#90be6d', '#43aa8b', '#277da1', '#ffffff'];
            for (let i = 0; i < 200; i++) { // 200 particles
                particles.push({
                    type: 'confetti',
                    x: width / 2, // Start at center
                    y: height / 2,
                    vx: (Math.random() - 0.5) * 15, // Explode horizontally
                    vy: (Math.random() - 0.5) * 20 - 5, // Explode upwards
                    size: Math.random() * 5 + 3,
                    color: confettiColors[Math.floor(Math.random() * confettiColors.length)],
                    life: 200 + Math.random() * 100 // Long life
                });
            }
        }

        // --- MODIFIED: Particle Physics ---
        function updateAndDrawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx; 
                p.y += p.vy; 
                p.life--;

                // NEW: Add gravity and drag to confetti
                if (p.type === 'confetti') {
                    p.vy += 0.1; // Gravity
                    p.vx *= 0.99; // Air drag
                }

                if (p.life <= 0) {
                    particles.splice(i, 1);
                } else {
                    ctx.save();
                    // Fade out regular particles, but not confetti (it fades by falling off screen)
                    if (p.type !== 'confetti') {
                        ctx.globalAlpha = p.life / 60;
                    } else {
                        ctx.globalAlpha = p.life / (200 + Math.random() * 100);
                    }
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                    ctx.restore();
                }
            }
        }

        // --- MODIFIED: Starfield Functions (for non-square) ---
        function createStar(width, height) {
            return {
                x: Math.random() * width, y: Math.random() * height,
                size: Math.random() * 2 + 1, speed: Math.random() * 0.5 + 0.2
            };
        }
        function initStars(width, height) {
            stars = [];
            for (let i = 0; i < 100; i++) {
                stars.push(createStar(width, height));
            }
        }
        function updateAndDrawStars(width, height) {
            ctx.save();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let star of stars) {
                star.y += star.speed;
                if (star.y > height) {
                    star.y = 0;
                    star.x = Math.random() * width;
                }
                ctx.fillRect(star.x, star.y, star.size, star.size);
            }
            ctx.restore();
        }

        // --- *** MAJOR BUG FIX *** ---
        // --- MODIFIED: Main game loop (for non-square AND fixing invisible meteors) ---
        function gameLoop() {
            // MODIFIED: Use gameContainer
            const cssWidth = gameContainer.clientWidth;
            const cssHeight = gameContainer.clientHeight;
            
            // 1. CLEAR THE CANVAS FIRST
            ctx.clearRect(0, 0, cssWidth, cssHeight); // Clear with full size
            
            // 2. DRAW BACKGROUND STUFF
            updateAndDrawStars(cssWidth, cssHeight);
            
            if (logoImageLoaded) {
                ctx.save();
                ctx.globalAlpha = 0.1;
                const logoSize = Math.min(cssWidth, cssHeight) * 0.9; // Base size on smaller dimension
                ctx.drawImage(logoImage, (cssWidth - logoSize) / 2, (cssHeight - logoSize) / 2, logoSize, logoSize);
                ctx.restore();
            }

            // 3. DRAW PARTICLES
            updateAndDrawParticles(); // Draw particles (confetti, thrusters, etc)

            // 4. RUN GAME LOGIC *IF* NOT GAME OVER
            if (!isGameOver) { 
                if (player.isShielded) {
                    shieldTimer--;
                    if (shieldTimer <= 0) player.isShielded = false;
                }
                if (player.invincibilityTimer > 0) player.invincibilityTimer--;

                updatePlayer();
                updateAndDrawObstacles(); // This will NOW be visible
                checkCollisions();

                obstacleSpawnTimer++;
                
                // --- MODIFICATION: Make spawn rate increase from the START ---
                // Gradually decrease spawn time from the beginning
                const progress = Math.min(1, score / 500); // 0.0 -> 1.0 as score goes 0 -> 500
                const baseInterval = 80; // Starting interval (was 100)
                const minInterval = 30; // Max spawn rate
                const reduction = (baseInterval - minInterval) * progress; // How much to reduce by
                obstacleSpawnInterval = Math.max(minInterval, baseInterval - reduction);
                // --- END MODIFICATION ---
                
                if (obstacleSpawnTimer >= obstacleSpawnInterval) {
                    createFallingObject();
                    obstacleSpawnTimer = 0;
                }
                
                // 5. DRAW FOREGROUND STUFF
                drawPlayer();
                drawUI();
            }

            // 6. LOOP
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        // --- *** END MAJOR BUG FIX *** ---
        
        // --- MODIFIED: Initial Game Start ---
        function main() {
            try {
                modalTitle.textContent = 'Void Runner'; // MODIFIED: New Name
                modalScore.innerHTML = `<span class="text-subtitle">Dodge the meteors!</span>`; // MODIFIED: Use new font class
                
                // --- MODIFICATION: REMOVED ALL AUTH CHECKS ---
                restartButton.textContent = 'Start Game';
                restartButton.disabled = false;
                
                // submitScoreForm.classList.add('hidden'); // REMOVED (already hidden)
                // leaderboardModalContainer.classList.add('hidden'); // REMOVED (already hidden)
                restartButton.classList.remove('hidden');
                modalBackdrop.classList.remove('hidden');
                endScreenVideo.classList.add('hidden'); // MODIFIED
                loadAllImages();
                // initFirebase(); // REMOVED
            } catch (error) {
                console.error("Error in main() function:", error);
                const modal = document.getElementById('modalBackdrop');
                if (modal) {
                    modal.classList.remove('hidden');
                    const title = document.getElementById('modalTitle');
                    if (title) title.textContent = 'Error loading game';
                }
            }
        }
        
        // --- MODIFIED: Main Startup Function ---
        function onDomReady() {
            // --- Assign all DOM elements ---
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            gameContainer = document.getElementById('game-container'); // NEW
            scoreEl = document.getElementById('score');
            modalBackdrop = document.getElementById('modalBackdrop');
            modalTitle = document.getElementById('modalTitle');
            modalScore = document.getElementById('modalScore');
            restartButton = document.getElementById('restartButton');
            endScreenVideo = document.getElementById('endScreenVideo'); // MODIFIED
            // leaderboardList = document.getElementById('leaderboardList'); // REMOVED
            // leaderboardModalContainer = document.getElementById('leaderboard-modal-container'); // REMOVED
            // submitScoreForm = document.getElementById('submitScoreForm'); // REMOVED
            // playerNameInput = document.getElementById('playerNameInput'); // REMOVED
            // submitScoreBtn = document.getElementById('submitScoreBtn'); // REMOVED
            moveLeftBtn = document.getElementById('moveLeftBtn');
            moveRightBtn = document.getElementById('moveRightBtn');
            catMemePlayer = document.getElementById('catMemePlayer'); // MODIFIED
            shieldVideoPlayer = document.getElementById('shieldVideoPlayer'); // NEW
            
            // --- Add all Event Listeners ---
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft' || e.key === 'a') moveLeft = true;
                if (e.key === 'ArrowRight' || e.key === 'd') moveRight = true;
            });
            document.addEventListener('keyup', (e) => {
                if (e.key === 'ArrowLeft' || e.key === 'a') moveLeft = false;
                if (e.key === 'ArrowRight' || e.key === 'd') moveRight = false;
            });
            moveLeftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); moveLeft = true; }, { passive: false });
            moveLeftBtn.addEventListener('touchend', (e) => { e.preventDefault(); moveLeft = false; }, { passive: false });
            moveRightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); moveRight = true; }, { passive: false });
            moveRightBtn.addEventListener('touchend', (e) => { e.preventDefault(); moveRight = false; }, { passive: false });
            
            // --- MODIFIED: Ultra-Failsafe Click Handler ---
            restartButton.addEventListener('click', () => {
                try {
                    // --- REMOVED AUTH CHECK ---

                    // If game is already running, this button is "Play Again", so just init.
                    // If this is the first start, soundInitialized will be false.
                    if (soundInitialized) {
                        initGame(); // Call directly
                        return;
                    }

                    // --- First time click: Try to start audio ---
                    if (typeof Tone !== 'undefined') {
                        
                        // Failsafe: Promise.race to prevent Tone.start() from hanging
                        const startAudio = () => {
                            return Tone.start().then(() => {
                                console.log("AudioContext started!");
                                initSounds(); // Define the synths
                                soundInitialized = true;
                            }).catch(e => {
                                console.error("Tone.start() failed, will run game without sound effects:", e);
                                soundInitialized = false; // Mark as failed
                            });
                        };

                        const audioTimeout = (ms) => {
                            return new Promise((resolve) => setTimeout(() => {
                                console.warn(`Tone.start() timed out after ${ms}ms.`);
                                resolve(); // Just resolve, don't reject
                            }, ms));
                        };

                        // Race Tone.start() against a 2-second timer
                        Promise.race([startAudio(), audioTimeout(2000)])
                            .finally(() => {
                                // Whether it succeeded, failed, or timed out, start the game.
                                console.log("Audio init finished or timed out. Starting game.");
                                initGame(); // Call directly
                            });
                        
                    } else {
                        // Tone.js isn't loaded.
                        console.warn("Tone.js not loaded. Starting game without sound effects.");
                        soundInitialized = false;
                        initGame(); // Call directly
                    }
                    
                } catch (e) {
                    console.error("Error in restart click handler:", e);
                     initGame(); // Failsafe: Call directly
                }
            });
            // --- END MODIFICATION ---

            // submitScoreBtn.addEventListener('click', submitScore); // REMOVED
            window.addEventListener('resize', resizeCanvas); // Resize canvas on window resize

            // --- Run the main startup logic ---
            resizeCanvas(); // Initial resize
            // MODIFIED: Use gameContainer
            initStars(gameContainer.clientWidth, gameContainer.clientHeight); // Initial star render
            main(); 
        }

        // --- Wait for DOM to be ready before running setup ---
        window.addEventListener('DOMContentLoaded', onDomReady);
        
    </script>
</body>
</html>

