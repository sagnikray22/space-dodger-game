<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Dodger</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Orbitron font -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <!-- NEW: Load Tone.js for sound, added defer -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js" defer></script>
    <style>
        body {
            font-family: 'Orbitron', sans-serif;
            overflow: hidden; /* Prevent scrolling on mobile */
            touch-action: none; /* Disable panning and zooming */
        }
        canvas {
            background-color: #1A0A2A; /* Dark Purple */
            touch-action: none; /* Disable touch gestures on canvas */
            /* Removed background-image from here, will be drawn on canvas */
        }
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
            backdrop-filter: blur(5px);
        }
        .text-glow-cyan {
            color: #e0faff;
            text-shadow: 0 0 2px #0ff, 0 0 6px #0ff, 0 0 12px #0ff;
        }
        .text-glow-yellow {
            color: #fffde0;
            text-shadow: 0 0 2px #ff0, 0 0 6px #ff0, 0 0 12px #ff0;
        }

        /* NEW: Leaderboard Styles */
        .leaderboard-container {
            width: 90%;
            max-width: 600px;
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #8B5CF6; /* Purple border */
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.5);
        }
        .leaderboard-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 200px;
            overflow-y: auto;
        }
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid rgba(139, 92, 246, 0.3);
            font-size: 0.9rem;
        }
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        .leaderboard-item .name {
            color: #fff;
        }
        .leaderboard-item .score {
            color: #FACC15; /* Yellow */
        }
    </style>
</head>
<body class="bg-purple-900 text-white flex flex-col items-center min-h-screen pt-4 pb-8">

    <!-- Game Title -->
    <h1 class="text-3xl md:text-4xl font-bold mb-4 text-glow-cyan">Space Dodger</h1>

    <!-- Score Display -->
    <div class="mb-4 text-lg md:text-2xl">
        Score: <span id="score" class="font-bold text-glow-yellow">0</span>
    </div>

    <!-- Game Canvas -->
    <div class="w-full md:max-w-3xl lg:max-w-4xl aspect-square rounded-lg shadow-2xl overflow-hidden border-2 border-purple-400">
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Mobile Touch Controls -->
    <div class="md:hidden w-full max-w-lg mt-4 grid grid-cols-2 gap-4 px-4 pb-4">
        <button id="moveLeftBtn" class="bg-gradient-to-b from-purple-600 to-purple-800 border-2 border-cyan-300 text-white font-bold py-4 rounded-lg shadow-lg active:scale-95 transition-transform duration-200 shadow-purple-500/50 active:shadow-none">
            &larr; Left
        </button>
        <button id="moveRightBtn" class="bg-gradient-to-b from-purple-600 to-purple-800 border-2 border-cyan-300 text-white font-bold py-4 rounded-lg shadow-lg active:scale-95 transition-transform duration-200 shadow-purple-500/50 active:shadow-none">
            Right &rarr;
        </button>
    </div>

    <!-- NEW: Leaderboard Section -->
    <div class="leaderboard-container">
        <h3 class="text-center text-xl font-bold text-glow-cyan mb-4">Top 10 Scores</h3>
        <ol id="leaderboardList" class="leaderboard-list">
            <!-- Scores will be populated by JavaScript -->
        </ol>
    </div>

    <!-- Game Over / Start Modal -->
    <div id="modalBackdrop" class="modal-backdrop hidden">
        <div id="gameModal" class="bg-gradient-to-b from-gray-800 to-gray-900 p-8 rounded-lg shadow-2xl shadow-cyan-500/50 text-center border-2 border-cyan-300">
            <img id="modalImage" src="" alt="Game Over" class="w-32 h-32 mx-auto mb-4 rounded-lg hidden">
            <h2 id="modalTitle" class="text-3xl font-bold mb-4 text-glow-cyan">Game Over!</h2>
            <p id="modalScore" class="text-xl mb-6">Your Score: 0</p>
            
            <!-- NEW: Submit Score Form -->
            <div id="submitScoreForm" class="hidden">
                <input type="text" id="playerNameInput" placeholder="Enter your name" class="w-full p-2 rounded bg-gray-700 text-white border border-purple-400 focus:outline-none focus:ring-2 focus:ring-cyan-300">
                <button id="submitScoreBtn" class="w-full mt-4 bg-green-500 text-white font-bold py-3 px-8 rounded-lg text-xl transform transition-all duration-300 hover:scale-105 shadow-lg shadow-green-500/50 disabled:bg-gray-500 disabled:shadow-none disabled:cursor-not-allowed">
                    Submit Score
                </button>
            </div>

            <!-- "Play Again" / "Start Game" Button -->
            <button id="restartButton" class="bg-yellow-500 text-gray-900 font-bold py-3 px-8 rounded-lg text-xl transform transition-all duration-300 hover:scale-105 shadow-lg shadow-yellow-500/50 hover:shadow-yellow-300/50">
                Play Again
            </button>
        </div>
    </div>

    <script type="module">
        // --- NEW: Firebase SDK Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, addDoc, collection, onSnapshot, query, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- MODIFIED: Declare variables, assign them after DOM loads ---
        let canvas, ctx;
        let scoreEl, modalBackdrop, modalTitle, modalScore, restartButton, modalImage;
        let leaderboardList, submitScoreForm, playerNameInput, submitScoreBtn;
        let moveLeftBtn, moveRightBtn;

        // --- Game State Variables ---
        let player, obstacles = [], score = 0, lives = 3;
        let gameSpeed = 1.0, isGameOver = false, animationFrameId;
        let obstacleSpawnTimer = 0, obstacleSpawnInterval = 100;
        let shieldTimer = 0;
        const SHIELD_DURATION = 300; // 5 seconds
        let moveLeft = false, moveRight = false;
        
        // --- NEW: AAA Feature Variables ---
        let particles = [];
        let stars = [];
        let musicLoop;

        // --- Image Assets ---
        let playerImage = new Image(), playerImageLoaded = false;
        const playerImageFilename = 'spaceship.png';
        let logoImage = new Image(), logoImageLoaded = false;
        const logoImageFilename = 'logo.png';
        let meteorImage = new Image(), meteorImageLoaded = false;
        const meteorImageFilename = 'meteor.png';
        let octopusImage = new Image(), octopusImageLoaded = false;
        const octopusImageFilename = 'octopus.png';

        // --- NEW: Firebase Variables ---
        let db, auth, userId, appId;
        let soundInitialized = false;

        // --- NEW: Sound Synthesizers (Tone.js) ---
        let synth, bombSynth, shieldSynth, hitSynth;
        
        function initSounds() {
            // Create SFX synths
            synth = new Tone.Synth().toDestination();
            bombSynth = new Tone.MembraneSynth().toDestination();
            shieldSynth = new Tone.Synth({
                oscillator: { type: "pulse", width: 0.8 },
                envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 }
            }).toDestination();
            hitSynth = new Tone.NoiseSynth({
                noise: { type: "pink" },
                envelope: { attack: 0.01, decay: 0.15, sustain: 0 }
            }).toDestination();

            // --- NEW: Create Music Synth and Loop ---
            const musicSynth = new Tone.MonoSynth({
                oscillator: { type: "fmsquare" },
                envelope: { attack: 0.01, decay: 0.1, release: 0.1 },
                filter: { Q: 2, type: "lowpass", rollover: -12 },
                filterEnvelope: { attack: 0.01, decay: 0.1, sustain: 0.5, release: 0.2, baseFrequency: 300, octaves: 2 }
            }).toDestination();
            musicSynth.volume.value = -18; // Make it quiet background music

            const notes = ["C2", null, "C2", "G1", "C2", "F2", "C2", null];
            let noteIndex = 0;
            musicLoop = new Tone.Loop(time => {
                let note = notes[noteIndex % notes.length];
                if (note) {
                    musicSynth.triggerAttackRelease(note, "8n", time);
                }
                noteIndex++;
            }, "8n"); // Play every 8th note
            // --- END NEW ---

            console.log("Sounds initialized");
            soundInitialized = true;
        }

        function playSound(sound) {
            if (!soundInitialized) return;

            const now = Tone.now();
            if (sound === 'shield') {
                shieldSynth.triggerAttackRelease("C5", "8n", now);
                shieldSynth.triggerAttackRelease("G5", "8n", now + 0.1);
            } else if (sound === 'hit') {
                hitSynth.triggerAttackRelease("4n", now);
            } else if (sound === 'gameover') {
                bombSynth.triggerAttackRelease("C2", "4n", now);
                bombSynth.triggerAttackRelease("G1", "4n", now + 0.2);
            }
        }
        
        // --- NEW: Firebase Initialization ---
        async function initFirebase() {
            try {
                // These global variables are provided by the environment
                appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const firebaseConfigStr = typeof __firebase_config !== 'undefined' ? __firebase_config : '{}';
                const firebaseConfig = JSON.parse(firebaseConfigStr);

                if (!firebaseConfig.apiKey) {
                    console.warn("Firebase config not found. Leaderboard will not work.");
                    return;
                }

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                // NEW: Enable debug logging
                setLogLevel('Debug');
                
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        console.log("User is signed in:", user.uid);
                        userId = user.uid;
                        // User is ready, load the leaderboard
                        loadLeaderboard();
                    } else {
                        console.log("User is signed out.");
                        userId = null;
                    }
                });

                // Sign in
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }

            } catch (error) {
                console.error("Firebase Init Error:", error);
            }
        }

        // --- NEW: Load Leaderboard Data ---
        function loadLeaderboard() {
            if (!db) {
                console.log("Leaderboard load skipped: DB not ready.");
                return;
            }
            
            const leaderboardCol = collection(db, `/artifacts/${appId}/public/data/leaderboard`);
            const q = query(leaderboardCol); // Get all scores

            onSnapshot(q, (snapshot) => {
                let scores = [];
                snapshot.forEach(doc => {
                    scores.push(doc.data());
                });

                // Sort and filter in memory
                const sortedScores = scores
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 10);
                
                displayLeaderboard(sortedScores);
            }, (error) => {
                console.error("Error loading leaderboard:", error);
            });
        }

        // --- NEW: Display Leaderboard ---
        function displayLeaderboard(scores) {
            leaderboardList.innerHTML = ''; // Clear old list
            if (scores.length === 0) {
                leaderboardList.innerHTML = '<li class="text-center text-gray-400">Be the first to set a score!</li>';
                return;
            }
            scores.forEach((entry, index) => {
                const li = document.createElement('li');
                li.className = 'leaderboard-item';
                li.innerHTML = `
                    <span class="name">${index + 1}. ${entry.name || 'Anonymous'}</span>
                    <span class="score">${entry.score}</span>
                `;
                leaderboardList.appendChild(li);
            });
        }

        // --- NEW: Submit Score ---
        async function submitScore() {
            const playerName = playerNameInput.value.trim();
            if (!playerName) {
                // We won't use alert()
                playerNameInput.placeholder = "Please enter your name!";
                playerNameInput.classList.add('border-red-500');
                setTimeout(() => {
                   playerNameInput.classList.remove('border-red-500');
                   playerNameInput.placeholder = "Enter your name";
                }, 2000);
                return;
            }
            if (!db || !userId) {
                console.error("Database not ready to submit score.");
                return;
            }

            try {
                const leaderboardCol = collection(db, `/artifacts/${appId}/public/data/leaderboard`);
                await addDoc(leaderboardCol, {
                    name: playerName,
                    score: score,
                    timestamp: new Date()
                });
                
                console.log("Score submitted!");
                // MODIFIED: Disable form instead of hiding it
                playerNameInput.disabled = true;
                submitScoreBtn.disabled = true;
                submitScoreBtn.textContent = 'Submitted!';
                submitScoreBtn.classList.remove('bg-green-500');
                submitScoreBtn.classList.add('bg-gray-500');

            } catch (error) {
                console.error("Error submitting score:", error);
            }
        }

        // --- Load Images ---
        function loadAllImages() {
            // Player image
            playerImage.src = playerImageFilename;
            playerImage.onload = () => playerImageLoaded = true;
            playerImage.onerror = () => console.error("Error loading player image");

            // Logo image
            logoImage.src = logoImageFilename;
            logoImage.onload = () => logoImageLoaded = true;
            logoImage.onerror = () => console.error("Error loading logo image");

            // Meteor image
            meteorImage.src = meteorImageFilename;
            meteorImage.onload = () => meteorImageLoaded = true;
            meteorImage.onerror = () => console.error("Error loading meteor image");

            // Octopus image
            octopusImage.src = octopusImageFilename;
            octopusImage.onload = () => octopusImageLoaded = true;
            octopusImage.onerror = () => console.error("Error loading octopus image");
        }


        // --- Game Functions ---

        // Resize canvas
        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = container.clientWidth;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            ctx.scale(dpr, dpr);
            
            if (player) {
                const oldSize = player.width / 0.15;
                const oldXRatio = player.x / oldSize;
                player.width = size * 0.15;
                player.height = player.width;
                player.speed = size * 0.008;
                player.x = oldXRatio * size;
                player.y = size - player.height - 10;
            }
            
            // --- NEW: Re-init stars on resize ---
            initStars(size);

            if (!isGameOver) {
                ctx.clearRect(0, 0, size, size);
                if(player) drawPlayer();
                updateAndDrawObstacles();
            }
        }

        // Create player
        function createPlayer() {
            const size = canvas.parentElement.clientWidth;
            const playerSize = size * 0.15;
            return {
                x: size / 2 - playerSize / 2,
                y: size - playerSize - 10,
                width: playerSize,
                height: playerSize,
                speed: size * 0.008,
                isShielded: false,
                invincibilityTimer: 0
            };
        }

        // Draw player
        function drawPlayer() {
            if (player.isShielded) {
                ctx.save();
                const centerX = player.x + player.width / 2;
                const centerY = player.y + player.height / 2;
                const radius = player.width * 0.7;
                const pulse = Math.abs(Math.sin(Date.now() * 0.01));
                ctx.fillStyle = `rgba(238, 130, 238, ${0.2 + pulse * 0.2})`;
                ctx.strokeStyle = `rgba(255, 0, 255, ${0.6 + pulse * 0.3})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }

            if (player.invincibilityTimer > 0 && Math.floor(player.invincibilityTimer / 10) % 2 === 0) {
                // Skip drawing to flicker
            } else {
                if (playerImageLoaded) {
                    ctx.drawImage(playerImage, player.x, player.y, player.width, player.height);
                } else {
                    ctx.fillStyle = '#4A90E2';
                    ctx.shadowColor = '#81D4FA';
                    ctx.shadowBlur = 15;
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                    ctx.shadowBlur = 0;
                }
            }
        }

        // Draw UI
        function drawUI() {
            const size = canvas.parentElement.clientWidth;
            const lifeSize = size * 0.05;
            const padding = size * 0.02;
            ctx.save();
            if (playerImageLoaded) {
                ctx.globalAlpha = 0.8;
                for (let i = 0; i < lives; i++) {
                    ctx.drawImage(playerImage, padding + i * (lifeSize + padding / 2), size - lifeSize - padding, lifeSize, lifeSize);
                }
                ctx.globalAlpha = 1.0;
            } else {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
                for (let i = 0; i < lives; i++) {
                    ctx.fillRect(padding + i * (lifeSize + padding / 2), size - lifeSize - padding, lifeSize, lifeSize);
                }
            }
            ctx.restore();
        }

        // Update player
        function updatePlayer() {
            if (moveLeft) player.x -= player.speed;
            if (moveRight) player.x += player.speed;
            
            // --- NEW: Emit thruster particles ---
            if(moveLeft || moveRight) {
                emitThrusterParticles();
            }

            const size = canvas.parentElement.clientWidth;
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > size) player.x = size - player.width;
        }

        // Create falling object
        function createFallingObject() {
            const size = canvas.parentElement.clientWidth;
            const objectSize = Math.random() * (size * 0.08) + (size * 0.03);
            let objectType = 'meteor', baseSpeed = gameSpeed;
            const rand = Math.random();
            if (rand < 0.05 && score > 200) {
                objectType = 'booster';
                baseSpeed = gameSpeed * 1.2;
            } else if (rand < 0.10 && score > 100) {
                objectType = 'bomb';
                baseSpeed = gameSpeed * 1.1;
            }
            obstacles.push({
                x: Math.random() * (size - objectSize), y: -objectSize,
                width: objectSize, height: objectSize,
                speed: Math.random() * 2 + baseSpeed, type: objectType
            });
        }

        // Draw bomb
        function drawBomb(x, y, radius) {
            ctx.save();
            const centerX = x + radius, centerY = y + radius;
            ctx.beginPath(); ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = '#222'; ctx.shadowColor = '#000'; ctx.shadowBlur = 10; ctx.fill();
            ctx.beginPath(); ctx.arc(centerX, centerY - radius * 0.8, radius * 0.2, 0, 2 * Math.PI);
            ctx.fillStyle = '#999'; ctx.fill();
            ctx.beginPath(); ctx.moveTo(centerX, centerY - radius * 0.9);
            ctx.lineTo(centerX + radius * 0.1, centerY - radius * 1.2);
            ctx.strokeStyle = '#555'; ctx.lineWidth = 3; ctx.stroke();
            ctx.beginPath(); ctx.arc(centerX + radius * 0.1, centerY - radius * 1.2, radius * 0.15, 0, 2 * Math.PI);
            ctx.fillStyle = 'yellow'; ctx.shadowColor = 'orange'; ctx.shadowBlur = 15; ctx.fill();
            ctx.restore();
        }

        // Draw booster
        function drawBooster(x, y, radius) {
            ctx.save();
            const centerX = x + radius, centerY = y + radius;
            ctx.beginPath(); ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            const gradient = ctx.createRadialGradient(centerX, centerY, radius * 0.2, centerX, centerY, radius);
            gradient.addColorStop(0, 'rgba(200, 255, 200, 1)');
            gradient.addColorStop(0.5, 'rgba(0, 255, 0, 0.8)');
            gradient.addColorStop(1, 'rgba(0, 150, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.shadowColor = '#00FF00'; ctx.shadowBlur = 20; ctx.fill();
            ctx.restore();
        }

        // Update/draw obstacles
        function updateAndDrawObstacles() {
            const size = canvas.parentElement.clientWidth;
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i];
                obs.y += obs.speed;
                if (obs.type === 'meteor') {
                    if (meteorImageLoaded) {
                        ctx.drawImage(meteorImage, obs.x, obs.y, obs.width, obs.height);
                    } else {
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                    }
                } else if (obs.type === 'bomb') {
                    drawBomb(obs.x, obs.y, obs.width / 2);
                } else if (obs.type === 'booster') {
                    drawBooster(obs.x, obs.y, obs.width / 2);
                }

                if (obs.y > size) {
                    obstacles.splice(i, 1);
                    score += 10;
                    scoreEl.textContent = score;
                    if (score >= 500 && score % 100 === 0) gameSpeed += 0.2;
                }
            }
        }

        // Check collisions
        function checkCollisions() {
            if (player.invincibilityTimer > 0) return;
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i];
                const padding = player.width * 0.15;
                if (player.x < obs.x + obs.width - padding && player.x + player.width > obs.x + padding &&
                    player.y < obs.y + obs.height - padding && player.y + player.height > obs.y + padding) {
                    
                    if (obs.type === 'booster') {
                        player.isShielded = true;
                        shieldTimer = SHIELD_DURATION;
                        obstacles.splice(i, 1);
                        playSound('shield');
                        // --- NEW: Emit shield particles ---
                        emitParticles(player.x + player.width / 2, player.y + player.height / 2, 20, '#00FF00');
                    } else if (obs.type === 'meteor' || obs.type === 'bomb') {
                        if (player.isShielded) {
                            obstacles.splice(i, 1);
                            playSound('hit');
                            // --- NEW: Emit shield hit particles ---
                            emitParticles(obs.x + obs.width / 2, obs.y + obs.height / 2, 30, '#FF00FF');
                        } else {
                            lives--;
                            playSound(obs.type === 'bomb' ? 'gameover' : 'hit');
                            // --- NEW: Emit player hit particles ---
                            emitParticles(player.x + player.width / 2, player.y + player.height / 2, 40, '#FF4500');
                            
                            obstacles.splice(i, 1);
                            if (lives <= 0) {
                                gameOver();
                                break;
                            } else {
                                player.invincibilityTimer = 240; // 4 seconds
                            }
                        }
                    }
                }
            }
        }

        // Game over
        function gameOver() {
            isGameOver = true;
            cancelAnimationFrame(animationFrameId);
            playSound('gameover');
            
            modalTitle.textContent = 'Game Over!';
            modalScore.innerHTML = `Your Score: <span class="font-bold text-glow-yellow">${score}</span>`;
            if (octopusImageLoaded) {
                modalImage.src = octopusImageFilename;
                modalImage.classList.remove('hidden');
            }
            // MODIFIED: Show submit form AND restart button
            submitScoreForm.classList.remove('hidden');
            restartButton.classList.remove('hidden');
            restartButton.textContent = 'Play Again'; // Set text
            
            modalBackdrop.classList.remove('hidden');
        }

        // Start/restart game
        function initGame() {
            // resizeCanvas(); // Already called by listener, but good to ensure
            const size = canvas.parentElement.clientWidth;
            initStars(size); // Re-init stars
            player = createPlayer();
            obstacles = [];
            particles = []; // Clear particles
            score = 0;
            lives = 3;
            gameSpeed = 1.0;
            isGameOver = false;
            obstacleSpawnTimer = 0;
            obstacleSpawnInterval = 100;
            shieldTimer = 0;
            
            scoreEl.textContent = '0';
            modalBackdrop.classList.add('hidden');
            modalImage.classList.add('hidden');
            
            // NEW: Reset submit form for next game
            playerNameInput.disabled = false;
            playerNameInput.value = ''; // Clear name
            submitScoreBtn.disabled = false;
            submitScoreBtn.textContent = 'Submit Score';
            submitScoreBtn.classList.add('bg-green-500');
            submitScoreBtn.classList.remove('bg-gray-500');
            submitScoreForm.classList.add('hidden'); // Hide it until next game over
            
            gameLoop();
        }
        
        // --- NEW: Particle Functions ---
        function emitParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4, // Random horizontal velocity
                    vy: (Math.random() - 0.5) * 4, // Random vertical velocity
                    size: Math.random() * 3 + 1,
                    color: color,
                    life: Math.random() * 60 + 30 // Life in frames
                });
            }
        }

        function emitThrusterParticles() {
            if (!player) return;
            const size = canvas.parentElement.clientWidth;
            // Add 1-2 particles
            for (let i = 0; i < 2; i++) {
                particles.push({
                    x: player.x + player.width / 2 + (Math.random() - 0.5) * (player.width * 0.5),
                    y: player.y + player.height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: Math.random() * 2 + 1.5, // Move downwards
                    size: Math.random() * 2 + 1,
                    color: '#FF4500', // Orange
                    life: Math.random() * 30 + 20
                });
            }
        }

        function updateAndDrawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                } else {
                    ctx.save();
                    ctx.globalAlpha = p.life / 60; // Fade out
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                    ctx.restore();
                }
            }
        }

        // --- NEW: Starfield Functions ---
        function createStar(size) {
            return {
                x: Math.random() * size,
                y: Math.random() * size,
                size: Math.random() * 2 + 1,
                speed: Math.random() * 0.5 + 0.2 // Slow speeds for parallax
            };
        }

        function initStars(size) {
            stars = []; // Clear stars
            for (let i = 0; i < 100; i++) {
                stars.push(createStar(size));
            }
        }

        function updateAndDrawStars(size) {
            ctx.save();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let star of stars) {
                star.y += star.speed;
                if (star.y > size) {
                    star.y = 0;
                    star.x = Math.random() * size;
                }
                ctx.fillRect(star.x, star.y, star.size, star.size);
            }
            ctx.restore();
        }


        // Main game loop
        function gameLoop() {
            if (isGameOver) return;
            if (player.isShielded) {
                shieldTimer--;
                if (shieldTimer <= 0) player.isShielded = false;
            }
            if (player.invincibilityTimer > 0) player.invincibilityTimer--;

            const size = canvas.parentElement.clientWidth;
            
            // --- MODIFIED: Draw Background ---
            ctx.fillStyle = '#1A0A2A';
            ctx.fillRect(0, 0, size, size);
            
            // --- NEW: Draw Stars ---
            updateAndDrawStars(size);
            
            // --- Draw Logo ---
            if (logoImageLoaded) {
                ctx.save();
                ctx.globalAlpha = 0.1;
                const logoSize = size * 0.9;
                ctx.drawImage(logoImage, (size - logoSize) / 2, (size - logoSize) / 2, logoSize, logoSize);
                ctx.restore();
            }
            
            // --- NEW: Draw Particles (under player) ---
            updateAndDrawParticles();

            // --- Draw Game Objects ---
            updatePlayer();
            drawPlayer();
            updateAndDrawObstacles();
            checkCollisions();
            drawUI();

            obstacleSpawnTimer++;
            if (score < 500) {
                obstacleSpawnInterval = 100;
            } else {
                obstacleSpawnInterval = Math.max(30, 100 - (gameSpeed - 1.0) * 15);
            }
            if (obstacleSpawnTimer >= obstacleSpawnInterval) {
                createFallingObject();
                obstacleSpawnTimer = 0;
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        // --- Initial Game Start ---
        function main() {
            try {
                // --- MODIFICATION ---
                // Try to show the modal FIRST. This is the most important part.
                modalTitle.textContent = 'Space Dodger';
                modalScore.textContent = 'Dodge the meteors!';
                restartButton.textContent = 'Start Game';
                submitScoreForm.classList.add('hidden');
                restartButton.classList.remove('hidden');
                modalBackdrop.classList.remove('hidden');
                modalImage.classList.add('hidden');
                // --- END MODIFICATION ---

                // Now, load everything else in the background.
                loadAllImages();
                initFirebase(); // NEW
                
            } catch (error) {
                console.error("Error in main() function:", error);
                // As a fallback, try to show the modal anyway
                const modal = document.getElementById('modalBackdrop');
                if (modal) {
                    modal.classList.remove('hidden');
                    const title = document.getElementById('modalTitle');
                    if (title) title.textContent = 'Error loading game';
                }
            }
        }
        
        // --- NEW: Main Startup Function ---
        function onDomReady() {
            // --- Assign all DOM elements ---
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            scoreEl = document.getElementById('score');
            modalBackdrop = document.getElementById('modalBackdrop');
            modalTitle = document.getElementById('modalTitle');
            modalScore = document.getElementById('modalScore');
            restartButton = document.getElementById('restartButton');
            modalImage = document.getElementById('modalImage');
            leaderboardList = document.getElementById('leaderboardList');
            submitScoreForm = document.getElementById('submitScoreForm');
            playerNameInput = document.getElementById('playerNameInput');
            submitScoreBtn = document.getElementById('submitScoreBtn');
            moveLeftBtn = document.getElementById('moveLeftBtn');
            moveRightBtn = document.getElementById('moveRightBtn');
            
            // --- Add all Event Listeners ---
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft' || e.key === 'a') moveLeft = true;
                if (e.key === 'ArrowRight' || e.key === 'd') moveRight = true;
            });
            document.addEventListener('keyup', (e) => {
                if (e.key === 'ArrowLeft' || e.key === 'a') moveLeft = false;
                if (e.key === 'ArrowRight' || e.key === 'd') moveRight = false;
            });
            moveLeftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); moveLeft = true; }, { passive: false });
            moveLeftBtn.addEventListener('touchend', (e) => { e.preventDefault(); moveLeft = false; }, { passive: false });
            moveRightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); moveRight = true; }, { passive: false });
            moveRightBtn.addEventListener('touchend', (e) => { e.preventDefault(); moveRight = false; }, { passive: false });
            
            restartButton.addEventListener('click', () => {
                if (!soundInitialized) {
                    Tone.start();
                    initSounds();
                }
                // --- NEW: Start music ---
                if (Tone.Transport.state !== 'started') {
                    Tone.Transport.start();
                    musicLoop.start(0); // Start the loop
                }
                initGame();
            });

            submitScoreBtn.addEventListener('click', submitScore);
            window.addEventListener('resize', resizeCanvas);

            // --- Run the main startup logic ---
            resizeCanvas(); // Set initial size
            initStars(canvas.parentElement.clientWidth); // Init stars
            main(); 
        }

        // --- NEW: Wait for DOM to be ready before running setup ---
        window.addEventListener('DOMContentLoaded', onDomReady);
        
    </script>
</body>
</html>

