<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Dodger</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Inter font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrolling on mobile */
            touch-action: none; /* Disable panning and zooming */
        }
        canvas {
            background-color: #1A0A2A; /* Dark Purple */
            touch-action: none; /* Disable touch gestures on canvas */
            
            /* New Purple Nebula/Starfield Background */
            background-image: 
                radial-gradient(circle at 20% 30%, rgba(200, 150, 255, 0.2), transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(180, 100, 220, 0.15), transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(220, 180, 255, 0.05), transparent 20%);
            background-size: 100% 100%;
        }
        /* Ensure the modal is centered and has a backdrop */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }
    </style>
</head>
<!-- MODIFIED: Changed bg-gray-900 to bg-purple-900 -->
<body class="bg-purple-900 text-white flex flex-col items-center min-h-screen pt-4">

    <!-- Game Title -->
    <h1 class="text-3xl md:text-4xl font-bold text-cyan-300 mb-4">Space Dodger</h1>

    <!-- Score Display -->
    <div class="mb-4 text-lg md:text-2xl">
        Score: <span id="score" class="font-bold text-yellow-300">0</span>
    </div>

    <!-- Game Canvas -->
    <!-- MODIFIED: Changed border-cyan-400 to border-purple-400 -->
    <div class="w-full md:max-w-3xl lg:max-w-4xl aspect-square rounded-lg shadow-2xl overflow-hidden border-2 border-purple-400">
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Mobile Touch Controls -->
    <!-- MODIFIED: Changed to purple theme -->
    <div class="md:hidden w-full max-w-lg mt-4 grid grid-cols-2 gap-4 px-4 pb-4">
        <button id="moveLeftBtn" class="bg-purple-600 active:bg-purple-700 text-white font-bold py-4 rounded-lg shadow-lg text-xl">
            &larr; Left
        </button>
        <button id="moveRightBtn" class="bg-purple-600 active:bg-purple-700 text-white font-bold py-4 rounded-lg shadow-lg text-xl">
            Right &rarr;
        </button>
    </div>

    <!-- Game Over / Start Modal -->
    <div id="modalBackdrop" class="modal-backdrop hidden">
        <div id="gameModal" class="bg-gray-800 p-8 rounded-lg shadow-xl text-center border-2 border-cyan-300">
            <h2 id="modalTitle" class="text-3xl font-bold mb-4">Game Over!</h2>
            <p id="modalScore" class="text-xl mb-6">Your Score: 0</p>
            <button id="restartButton" class="bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold py-3 px-8 rounded-lg text-xl transition duration-200">
                Play Again
            </button>
        </div>
    </div>

    <script type="module">
        // --- Canvas & Context Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- DOM Elements ---
        const scoreEl = document.getElementById('score');
        const modalBackdrop = document.getElementById('modalBackdrop');
        const modalTitle = document.getElementById('modalTitle');
        const modalScore = document.getElementById('modalScore');
        const restartButton = document.getElementById('restartButton');
        
        // --- Mobile Controls ---
        const moveLeftBtn = document.getElementById('moveLeftBtn');
        const moveRightBtn = document.getElementById('moveRightBtn');

        // --- Game State Variables ---
        let player;
        let obstacles = [];
        let score = 0;
        let lives = 3; // --- NEW: Player lives ---
        let gameSpeed = 1.0; // Start with slow speed
        let isGameOver = false;
        let animationFrameId;
        
        // Difficulty timers
        let obstacleSpawnTimer = 0;
        let obstacleSpawnInterval = 100; // Start with slower spawn rate (was 70)

        // Shield timer
        let shieldTimer = 0;
        const SHIELD_DURATION = 300; // 300 frames = 5 seconds at 60fps

        // Player movement state
        let moveLeft = false;
        let moveRight = false;
        
        // --- Player Image ---
        let playerImage = new Image();
        let playerImageLoaded = false;
        const playerImageFilename = 'spaceship.png'; // The file you uploaded to GitHub

        // --- Logo Image ---
        let logoImage = new Image();
        let logoImageLoaded = false;
        const logoImageFilename = 'logo.png'; // The logo file you're uploading

        // --- Meteor Image ---
        let meteorImage = new Image();
        let meteorImageLoaded = false;
        const meteorImageFilename = 'meteor.png';
        // --- END NEW ---

        // --- Load Images ---
        // Load player image
        playerImage.src = playerImageFilename;
        playerImage.onload = function() {
            playerImageLoaded = true;
            console.log("Player image loaded successfully!");
        }
        playerImage.onerror = function() {
            playerImageLoaded = false; // Fallback to drawing a square
            console.error("Error loading player image: " + playerImageFilename);
        }

        // Load logo image
        logoImage.src = logoImageFilename;
        logoImage.onload = function() {
            logoImageLoaded = true;
            console.log("Logo image loaded successfully!");
        }
        logoImage.onerror = function() {
            logoImageLoaded = false;
            console.error("Error loading logo image: " + logoImageFilename);
        }

        // Load meteor image
        meteorImage.src = meteorImageFilename;
        meteorImage.onload = function() {
            meteorImageLoaded = true;
            console.log("Meteor image loaded successfully!");
        }
        meteorImage.onerror = function() {
            meteorImageLoaded = false;
            console.error("Error loading meteor image: " + meteorImageFilename);
        }
        // --- END NEW ---


        // --- Game Functions ---

        // Resize canvas to fit its container
        function resizeCanvas() {
            // Get the container's size
            const container = canvas.parentElement;
            const size = container.clientWidth; // CSS pixel size
            
            // --- NEW: High DPI Scaling ---
            const dpr = window.devicePixelRatio || 1;
            
            // Set canvas internal resolution to match physical pixels
            canvas.width = size * dpr;
            canvas.height = size * dpr;

            // Set the CSS display size (this doesn't change)
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            
            // Scale the context so we can use CSS pixels for drawing
            ctx.scale(dpr, dpr);
            // --- END NEW ---

            // Update player size/position (if player exists)
            if (player) {
                // Get the old *CSS size* of the canvas, which player.width was based on
                const oldSize = player.width / 0.15; 
        
                // Get new proportional x position
                const oldXRatio = player.x / oldSize;
                
                // Set new size based on new CSS size
                player.width = size * 0.15; // 15% of CSS canvas width
                player.height = player.width; // Keep it square
                player.speed = size * 0.008; // MODIFIED: Responsive speed (was 0.015)
                
                // Set new position
                player.x = oldXRatio * size;
                player.y = size - player.height - 10;
            }
            
            // Redraw if game is running
            if (!isGameOver) {
                // Clear and redraw all elements (or just player)
                ctx.clearRect(0, 0, size, size); // Use CSS size
                if(player) drawPlayer();
                updateAndDrawObstacles(); // Redraw existing obstacles
            }
        }

        // Create the player object
        function createPlayer() {
            const size = canvas.parentElement.clientWidth; // Get CSS size
            const playerSize = size * 0.15; // 15% of CSS canvas width
            return {
                x: size / 2 - playerSize / 2,
                y: size - playerSize - 10,
                width: playerSize,
                height: playerSize,
                speed: size * 0.008, // MODIFIED: Responsive speed (was 0.015)
                dx: 0, // Horizontal velocity
                isShielded: false,
                invincibilityTimer: 0 // --- NEW: For hit flashing ---
            };
        }

        // Draw the player (Image or Fallback)
        function drawPlayer() {
            // --- NEW: Draw Shield if active ---
            if (player.isShielded) {
                ctx.save();
                const centerX = player.x + player.width / 2;
                const centerY = player.y + player.height / 2;
                const radius = player.width * 0.7; // Shield radius
                
                // Create a pulsing effect
                const pulse = Math.abs(Math.sin(Date.now() * 0.01));
                
                // MODIFIED: Changed shield to purple/pink
                ctx.fillStyle = `rgba(238, 130, 238, ${0.2 + pulse * 0.2})`; // Pulsing violet fill
                ctx.strokeStyle = `rgba(255, 0, 255, ${0.6 + pulse * 0.3})`; // Pulsing magenta border
                ctx.lineWidth = 3;

                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }
            // --- END NEW ---

            // --- NEW: Handle Invincibility Flicker ---
            // Blink every 10 frames
            if (player.invincibilityTimer > 0 && Math.floor(player.invincibilityTimer / 10) % 2 === 0) {
                // On an even "blink" frame, skip drawing the player
            } else {
                // Draw player normally
                if (playerImageLoaded) {
                    ctx.drawImage(playerImage, player.x, player.y, player.width, player.height);
                } else {
                    // Fallback if image fails to load: draw a blue square
                    ctx.fillStyle = '#4A90E2'; // Blue
                    ctx.shadowColor = '#81D4FA'; // Light blue glow
                    ctx.shadowBlur = 15;
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                    ctx.shadowBlur = 0; // Reset shadow
                }
            }
            // --- END NEW ---
        }

        // --- NEW: Draw UI (Lives) ---
        function drawUI() {
            const size = canvas.parentElement.clientWidth; // Get CSS size
            const lifeSize = size * 0.05; // Size of the life icon
            const padding = size * 0.02; // Padding from edge
            
            ctx.save();
            
            // Draw life icons (mini ships)
            if (playerImageLoaded) {
                ctx.globalAlpha = 0.8; // Slightly transparent
                for (let i = 0; i < lives; i++) {
                    ctx.drawImage(
                        playerImage, 
                        padding + i * (lifeSize + padding / 2), // x position
                        size - lifeSize - padding, // y position (bottom left)
                        lifeSize, // width
                        lifeSize // height
                    );
                }
                ctx.globalAlpha = 1.0;
            } else {
                // Fallback: Draw simple green squares
                ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
                for (let i = 0; i < lives; i++) {
                        ctx.fillRect(
                        padding + i * (lifeSize + padding / 2), 
                        size - lifeSize - padding, 
                        lifeSize, 
                        lifeSize
                    );
                }
            }
            ctx.restore();
        }

        // Update player's position
        function updatePlayer() {
            if (moveLeft) {
                player.x -= player.speed;
            }
            if (moveRight) {
                player.x += player.speed;
            }

            // Keep player within canvas bounds
            const size = canvas.parentElement.clientWidth; // Get CSS size
            if (player.x < 0) {
                player.x = 0;
            }
            if (player.x + player.width > size) {
                player.x = size - player.width;
            }
        }

        // Create a new falling object (meteor, bomb, or booster)
        function createFallingObject() {
            const size = canvas.parentElement.clientWidth; // Get CSS size
            const objectSize = Math.random() * (size * 0.08) + (size * 0.03); // Random size
            let objectType = 'meteor'; // Default type
            let baseSpeed = gameSpeed;

            const rand = Math.random();
            if (rand < 0.05 && score > 200) { // 5% chance for a booster (after 200 points)
                objectType = 'booster';
                baseSpeed = gameSpeed * 1.2; // Boosters fall a little faster
            } else if (rand < 0.15 && score > 100) { // 10% chance for a bomb (after 100 points)
                objectType = 'bomb';
                baseSpeed = gameSpeed * 1.1; // Bombs fall a little faster
            }
            // 85% chance for a meteor

            obstacles.push({
                x: Math.random() * (size - objectSize), // Random x position
                y: -objectSize, // Start above the screen
                width: objectSize,
                height: objectSize,
                speed: Math.random() * 2 + baseSpeed, // Random speed
                type: objectType // 'meteor', 'bomb', or 'booster'
            });
        }

        // --- MODIFIED: Function to draw a Bomb (classic cartoon style) ---
        function drawBomb(x, y, radius) {
            ctx.save();
            const centerX = x + radius;
            const centerY = y + radius;

            // Black bomb body
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = '#222'; // Dark black/grey
            ctx.shadowColor = '#000';
            ctx.shadowBlur = 10;
            ctx.fill();

            // Grey 'cap' for the fuse
            ctx.beginPath();
            ctx.arc(centerX, centerY - radius * 0.8, radius * 0.2, 0, 2 * Math.PI);
            ctx.fillStyle = '#999'; // Grey
            ctx.fill();

            // Simple fuse (a line)
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - radius * 0.9);
            ctx.lineTo(centerX + radius * 0.1, centerY - radius * 1.2);
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Spark
            ctx.beginPath();
            ctx.arc(centerX + radius * 0.1, centerY - radius * 1.2, radius * 0.15, 0, 2 * Math.PI);
            ctx.fillStyle = 'yellow';
            ctx.shadowColor = 'orange';
            ctx.shadowBlur = 15;
            ctx.fill();
            
            ctx.restore();
        }

        // --- MODIFIED: Function to draw a Booster (Green Orb) ---
        function drawBooster(x, y, radius) {
            ctx.save();
            const centerX = x + radius;
            const centerY = y + radius;

            // Glowing green orb
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            
            // Create a radial gradient for a glow effect
            const gradient = ctx.createRadialGradient(centerX, centerY, radius * 0.2, centerX, centerY, radius);
            gradient.addColorStop(0, 'rgba(200, 255, 200, 1)'); // Bright green center
            gradient.addColorStop(0.5, 'rgba(0, 255, 0, 0.8)'); // Green
            gradient.addColorStop(1, 'rgba(0, 150, 0, 0)'); // Fades to dark green
            
            ctx.fillStyle = gradient;
            ctx.shadowColor = '#00FF00'; // Green glow
            ctx.shadowBlur = 20;
            ctx.fill();
            
            ctx.restore();
        }


        // --- DELETED: The old drawMeteor function ---


        // Update and draw all obstacles
        function updateAndDrawObstacles() {
            const size = canvas.parentElement.clientWidth; // Get CSS size
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i];
                obs.y += obs.speed; // Move obstacle down

                // Draw the object based on its type
                // --- MODIFIED: Draw meteor.png ---
                if (obs.type === 'meteor') {
                    if (meteorImageLoaded) {
                        ctx.drawImage(meteorImage, obs.x, obs.y, obs.width, obs.height);
                    } else {
                        // Fallback if image fails: draw a simple brown square
                        ctx.fillStyle = '#8B4513'; // SaddleBrown
                        ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                    }
                } else if (obs.type === 'bomb') {
                    drawBomb(obs.x, obs.y, obs.width / 2);
                } else if (obs.type === 'booster') {
                    drawBooster(obs.x, obs.y, obs.width / 2);
                }
                // --- END MODIFICATION ---


                // Remove obstacle if it's off-screen
                if (obs.y > size) { // Use CSS size
                    obstacles.splice(i, 1);
                    score += 10; // Add to score for dodging
                    scoreEl.textContent = score;

                    // --- Difficulty Ramp ---
                    // Increase game speed every 100 points, ONLY AFTER 500
                    if (score >= 500 && score % 100 === 0) {
                        gameSpeed += 0.2; // Slowly increase speed
                    }
                }
            }
        }

        // Check for collisions between player and obstacles
        function checkCollisions() {
            // --- NEW: Check for invincibility ---
            if (player.invincibilityTimer > 0) return;

            // Use a reverse loop so we can safely remove items
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i];

                // Simple AABB (Axis-Aligned Bounding Box) collision detection
                const padding = player.width * 0.15; // 15% padding
                
                if (
                    player.x < obs.x + obs.width - padding &&
                    player.x + player.width > obs.x + padding &&
                    player.y < obs.y + obs.height - padding &&
                    player.y + player.height > obs.y + padding
                ) {
                    // Collision detected!
                    
                    if (obs.type === 'booster') {
                        // Collected a booster!
                        player.isShielded = true;
                        shieldTimer = SHIELD_DURATION;
                        obstacles.splice(i, 1); // Remove the booster
                    
                    } else if (obs.type === 'meteor' || obs.type === 'bomb') {
                        // Hit a meteor or bomb
                        if (player.isShielded) {
                            // Shield protected the player!
                            obstacles.splice(i, 1); // Destroy the obstacle
                            player.isShielded = false; // --- NEW: Shield breaks on hit ---
                        } else {
                            // --- MODIFIED: Lose a life ---
                            lives--;
                            obstacles.splice(i, 1); // Destroy the obstacle
                            
                            if (lives <= 0) {
                                gameOver();
                                break; // Exit loop
                            } else {
                                // Player has lives left, grant temporary invincibility
                                player.invincibilityTimer = 180; // 3 seconds
                            }
                            // --- END MODIFICATION ---
                        }
                    }
                }
            }
        }

        // Handle game over
        function gameOver() {
            isGameOver = true;
            cancelAnimationFrame(animationFrameId); // Stop the game loop
            
            // Show game over modal
            modalTitle.textContent = 'Game Over!';
            modalScore.textContent = `Your Score: ${score}`;
            modalBackdrop.classList.remove('hidden');
        }

        // Start or restart the game
        function initGame() {
            // Resize canvas to fit container on start
            resizeCanvas();
            
            // Initialize game variables
            player = createPlayer();
            obstacles = [];
            score = 0;
            lives = 3; // --- NEW: Reset lives ---
            gameSpeed = 1.0; // Reset base speed
            isGameOver = false;
            obstacleSpawnTimer = 0;
            obstacleSpawnInterval = 100; // Reset spawn rate (was 70)
            shieldTimer = 0; // Reset shield timer
            
            // Reset UI
            scoreEl.textContent = '0';
            modalBackdrop.classList.add('hidden');
            
            // Start the game loop
            gameLoop();
        }

        // --- Main Game Loop ---
        function gameLoop() {
            if (isGameOver) return;

            // --- Shield Timer Countdown ---
            if (player.isShielded) {
                shieldTimer--;
                if (shieldTimer <= 0) {
                    player.isShielded = false;
                }
            }

            // --- NEW: Invincibility Timer Countdown ---
            if (player.invincibilityTimer > 0) {
                player.invincibilityTimer--;
            }
            // --- END NEW ---

            // Clear the canvas and draw background
            const size = canvas.parentElement.clientWidth; // Get CSS size
            
            // 1. Draw solid dark purple background
            ctx.fillStyle = '#1A0A2A';
            ctx.fillRect(0, 0, size, size);

            // 2. Draw the logo as a transparent watermark (if loaded)
            if (logoImageLoaded) {
                ctx.save();
                ctx.globalAlpha = 0.1; // 10% opacity
                const logoSize = size * 0.9; // MODIFIED: Was 0.6 (60%), now 90%
                const x = (size - logoSize) / 2;
                const y = (size - logoSize) / 2;
                ctx.drawImage(logoImage, x, y, logoSize, logoSize);
                ctx.restore(); // Restore alpha
            }

            // Update and draw game elements
            updatePlayer();
            drawPlayer();
            updateAndDrawObstacles();

            // Check for collisions
            checkCollisions();

            // --- NEW: Draw UI on top ---
            drawUI();

            // --- Spawn new obstacles based on difficulty ramp ---
            obstacleSpawnTimer++;

            if (score < 500) {
                obstacleSpawnInterval = 100; // Constant slow spawn rate (was 70)
            } else {
                // After 500, make obstacles spawn faster
                // Start from 100, go down to a max of 30
                obstacleSpawnInterval = Math.max(30, 100 - (gameSpeed - 1.0) * 15);
            }
            
            if (obstacleSpawnTimer >= obstacleSpawnInterval) {
                createFallingObject(); 
                obstacleSpawnTimer = 0;
            }

            // --- ADDED: Request next frame ---
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        // --- Event Handlers ---
        function handleKeyDown(e) {
            if (e.key === 'ArrowLeft' || e.key === 'a') {
                moveLeft = true;
            } else if (e.key === 'ArrowRight' || e.key === 'd') {
                moveRight = true;
            }
        }

        function handleKeyUp(e) {
            if (e.key === 'ArrowLeft' || e.key === 'a') {
                moveLeft = false;
            } else if (e.key === 'ArrowRight' || e.key === 'd') {
                moveRight = false;
            }
        }

        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);

        // Touch controls
        moveLeftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); moveLeft = true; }, { passive: false });
        moveLeftBtn.addEventListener('touchend', (e) => { e.preventDefault(); moveLeft = false; }, { passive: false });
        moveRightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); moveRight = true; }, { passive: false });
        moveRightBtn.addEventListener('touchend', (e) => { e.preventDefault(); moveRight = false; }, { passive: false });

        // Restart button
        restartButton.addEventListener('click', initGame);

        // Window resize
        window.addEventListener('resize', resizeCanvas);

        // --- Initial Game Start ---
        // Show "Start Game" modal on first load
        modalTitle.textContent = 'Space Dodger';
        modalScore.textContent = 'Dodge the meteors!';
        restartButton.textContent = 'Start Game';
        modalBackdrop.classList.remove('hidden');
        
        // We don't call initGame() here, we wait for the user to click "Start Game"
        
    </script>
</body>
</html>

